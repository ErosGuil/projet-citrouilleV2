<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MINI-JEUX BONUS - PROJET CITROUILLE</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Courier New', monospace;
            background: linear-gradient(135deg, #1a0a00 0%, #0a0a0a 100%);
            color: #0f0;
            min-height: 100vh;
            padding: 20px;
        }

        .header {
            text-align: center;
            margin-bottom: 30px;
            padding: 20px;
            background: rgba(0, 0, 0, 0.8);
            border: 3px solid #ff6600;
            border-radius: 10px;
            box-shadow: 0 0 30px rgba(255, 102, 0, 0.5);
        }

            .header h1 {
                color: #ff6600;
                font-size: 32px;
                text-shadow: 0 0 20px #ff6600;
                margin-bottom: 10px;
            }

            .header p {
                color: #0f0;
                font-size: 14px;
            }

        .games-container {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(min(350px, 100%), 1fr));
            gap: 20px;
            max-width: 1200px;
            margin: 0 auto;
        }

        .game-card {
            background: rgba(0, 0, 0, 0.9);
            border: 2px solid #0f0;
            border-radius: 10px;
            padding: 20px;
            box-shadow: 0 0 20px rgba(0, 255, 0, 0.3);
            transition: all 0.3s;
            overflow: hidden;
            position: relative;
        }

            .game-card:hover {
                border-color: #ff6600;
                box-shadow: 0 0 30px rgba(255, 102, 0, 0.5);
                transform: translateY(-5px);
            }

            .game-card h2 {
                color: #ff6600;
                margin-bottom: 15px;
                font-size: 24px;
                text-align: center;
            }

        .game-area {
            margin: 20px 0;
            min-height: 300px;
        }

        button {
            width: 100%;
            padding: 12px;
            background: #ff6600;
            color: #000;
            border: none;
            font-family: 'Courier New', monospace;
            font-size: 16px;
            font-weight: bold;
            cursor: pointer;
            border-radius: 5px;
            transition: all 0.3s;
            margin-top: 10px;
        }

            button:hover {
                background: #ff8800;
                box-shadow: 0 0 20px rgba(255, 102, 0, 0.8);
            }

        /* Tir aux citrouilles */
        #shootingGame {
            position: relative;
            width: 100%;
            height: 400px;
            background: #000;
            border: 2px solid #0f0;
            border-radius: 5px;
            overflow: hidden;
            cursor: crosshair;
        }

        .pumpkin-target {
            position: absolute;
            font-size: 40px;
            cursor: pointer;
            animation: float-pumpkin 3s ease-in-out infinite;
            user-select: none;
        }

        @keyframes float-pumpkin {
            0%, 100% {
                transform: translateY(0) rotate(0deg);
            }

            50% {
                transform: translateY(-20px) rotate(10deg);
            }
        }

        .explosion {
            position: absolute;
            font-size: 60px;
            animation: explode 0.5s ease-out forwards;
            pointer-events: none;
        }

        @keyframes explode {
            0% {
                transform: scale(0) rotate(0deg);
                opacity: 1;
            }

            100% {
                transform: scale(2) rotate(360deg);
                opacity: 0;
            }
        }

        .score-display {
            text-align: center;
            font-size: 24px;
            color: #ff6600;
            margin: 10px 0;
            font-weight: bold;
        }


        /* Typing Game */
        #typingGame {
            text-align: center;
        }

        .typing-target {
            background: rgba(0, 255, 0, 0.1);
            border: 2px solid #0f0;
            padding: 20px;
            margin: 20px 0;
            border-radius: 5px;
            font-size: 24px;
            color: #ff6600;
            letter-spacing: 2px;
            min-height: 80px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        #typingInput {
            width: 100%;
            padding: 15px;
            background: rgba(0, 0, 0, 0.8);
            border: 2px solid #0f0;
            color: #0f0;
            font-family: 'Courier New', monospace;
            font-size: 18px;
            text-align: center;
            border-radius: 5px;
        }

            #typingInput:focus {
                outline: none;
                border-color: #ff6600;
                box-shadow: 0 0 20px rgba(255, 102, 0, 0.5);
            }

        .timer {
            font-size: 32px;
            color: #f00;
            margin: 10px 0;
            font-weight: bold;
        }

        .stats {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 10px;
            margin: 15px 0;
        }

        .stat-box {
            background: rgba(255, 102, 0, 0.2);
            border: 2px solid #ff6600;
            padding: 10px;
            border-radius: 5px;
            text-align: center;
        }

        .stat-label {
            color: #0f0;
            font-size: 12px;
            margin-bottom: 5px;
        }

        .stat-value {
            color: #ff6600;
            font-size: 20px;
            font-weight: bold;
        }

        .message {
            text-align: center;
            padding: 15px;
            margin: 10px 0;
            border-radius: 5px;
            font-weight: bold;
        }

            .message.success {
                background: rgba(0, 255, 0, 0.2);
                border: 2px solid #0f0;
                color: #0f0;
            }

            .message.error {
                background: rgba(255, 0, 0, 0.2);
                border: 2px solid #f00;
                color: #f00;
            }

        @keyframes shake {
            0%, 100% {
                transform: translateX(0);
            }

            25% {
                transform: translateX(-10px);
            }

            75% {
                transform: translateX(10px);
            }
        }

        .shake {
            animation: shake 0.3s;
        }

        @keyframes fadeUp {
            0% {
                transform: translateY(0);
                opacity: 1;
            }

            100% {
                transform: translateY(-50px);
                opacity: 0;
            }
        }

        .shooting-target {
            animation: pulse 0.5s infinite alternate;
        }

            .shooting-target.gold {
                filter: drop-shadow(0 0 10px #ffaa00);
            }

            .shooting-target.bad:hover {
                filter: brightness(1.5);
            }

        /* Media queries pour mobile */
        @media (max-width: 768px) {
            .games-container {
                grid-template-columns: 1fr;
            }

            .game-card {
                padding: 15px;
            }

                .game-card h2 {
                    font-size: 20px;
                }

            #shootingGame {
                height: 300px;
            }


            #diffImage1, #diffImage2 {
                max-width: 100% !important;
                height: 250px !important;
            }

            .stats {
                gap: 5px;
            }

            .stat-box {
                padding: 8px;
            }

            .stat-label {
                font-size: 10px;
            }

            .stat-value {
                font-size: 16px;
            }

            #mazeContainer {
                max-width: 100% !important;
                width: calc(100vw - 60px) !important;
                margin: 15px auto !important;
            }

            body {
                padding: 10px !important;
            }

            .maze-btn {
                width: 60px;
                height: 60px;
                background: rgba(255, 102, 0, 0.3);
                color: #ff6600;
                border: 2px solid #ff6600;
                font-size: 24px;
                font-weight: bold;
                cursor: pointer;
                border-radius: 8px;
                transition: all 0.2s;
                user-select: none;
                display: flex;
                align-items: center;
                justify-content: center;
                padding: 0;
            }

                .maze-btn:hover:not(:disabled) {
                    background: rgba(255, 102, 0, 0.5);
                    transform: scale(1.05);
                    box-shadow: 0 0 15px rgba(255, 102, 0, 0.6);
                }

                .maze-btn:active:not(:disabled) {
                    transform: scale(0.95);
                    background: rgba(255, 102, 0, 0.7);
                }

                .maze-btn:disabled {
                    opacity: 0.3;
                    cursor: not-allowed;
                }

                .maze-btn.pressed {
                    background: rgba(255, 102, 0, 0.8);
                    transform: scale(0.9);
                    box-shadow: 0 0 20px rgba(255, 102, 0, 0.8);
                }

            @media (max-width: 600px) {
                .maze-btn {
                    width: 50px;
                    height: 50px;
                    font-size: 20px;
                }

                #mazeContainer {
                    max-width: 90vw !important;
                }
            }
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>🎃 MINI-JEUX BONUS 🎃</h1>
        <p>PROJET CITROUILLE - ZONE DE DÉTENTE</p>
    </div>

    <div class="games-container">
        <!-- Tir aux citrouilles -->
        <div class="game-card">
            <h2>🎯 TIR AUX CITROUILLES</h2>
            <div class="score-display">
                Score: <span id="shootScore">0</span> | Temps: <span id="shootTime">30</span>s
            </div>
            <div id="shootingGame"></div>
            <button onclick="startShooting()">DÉMARRER</button>
        </div>



        <!-- Typing Game -->
        <div class="game-card">
            <h2>⌨️ TYPING GAME</h2>
            <div class="timer">Temps: <span id="typingTimer">60</span>s</div>
            <div class="stats">
                <div class="stat-box">
                    <div class="stat-label">Score</div>
                    <div class="stat-value" id="typingScore">0</div>
                </div>
                <div class="stat-box">
                    <div class="stat-label">Précision</div>
                    <div class="stat-value" id="typingAccuracy">100%</div>
                </div>
                <div class="stat-box">
                    <div class="stat-label">WPM</div>
                    <div class="stat-value" id="typingWPM">0</div>
                </div>
            </div>
            <div id="typingGame">
                <div class="typing-target" id="typingTarget">Cliquez sur DÉMARRER</div>
                <input type="text" id="typingInput" placeholder="Tapez ici..." disabled>
                <div id="typingMessage"></div>
            </div>
            <button onclick="startTyping()">DÉMARRER</button>
        </div>
        <!-- Endless Runner -->
        <div class="game-card">
            <h2>🏃 ENDLESS RUNNER MAUDIT</h2>
            <div class="stats">
                <div class="stat-box">
                    <div class="stat-label">Distance</div>
                    <div class="stat-value" id="runnerDistance">0m</div>
                </div>
                <div class="stat-box">
                    <div class="stat-label">Record</div>
                    <div class="stat-value" id="runnerBest">0m</div>
                </div>
                <div class="stat-box">
                    <div class="stat-label">Vitesse</div>
                    <div class="stat-value" id="runnerSpeed">1x</div>
                </div>
            </div>
            <div id="runnerGame" style="position: relative; width: 100%; height: 350px; background: linear-gradient(to bottom, #1a0a2e 0%, #0f0520 50%, #16213e 100%); border: 2px solid #0f0; border-radius: 5px; overflow: hidden; cursor: pointer;">
                <div id="runnerGround" style="position: absolute; bottom: 0; width: 100%; height: 80px; background: #2d1810; border-top: 3px solid #ff6600;"></div>
                <div id="runnerPlayer" style="position: absolute; bottom: 80px; left: 50px; font-size: 40px; transition: bottom 0.1s;">
                    🎃
                </div>
                <div id="runnerStartText" style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); color: #ff6600; font-size: 24px; text-align: center; z-index: 100;">
                    Cliquez ou ESPACE pour sauter<br>
                    <span style="font-size: 16px; color: #0f0;">Évitez les obstacles !</span>
                </div>
            </div>
            <button onclick="startRunner()" id="runnerStartBtn">DÉMARRER LA COURSE</button>
        </div>



        <!-- Labyrinthe dans le Noir -->
        <div class="game-card">
            <h2>🔦 LABYRINTHE DANS LE NOIR</h2>
            <div class="stats">
                <div class="stat-box">
                    <div class="stat-label">Vies</div>
                    <div class="stat-value" id="mazeHP" style="color: #f00;">❤️❤️❤️</div>
                </div>
                <div class="stat-box">
                    <div class="stat-label">Sortie</div>
                    <div class="stat-value" id="mazeProgress">0%</div>
                </div>
                <div class="stat-box">
                    <div class="stat-label">Temps</div>
                    <div class="stat-value" id="mazeTime">0s</div>
                </div>
            </div>

            <div style="text-align: center; color: #0f0; margin: 15px 0; font-size: 14px;" id="mazeHint">
                Utilisez les flèches du clavier ou les boutons ci-dessous
            </div>

            <div id="mazeContainer" style="position: relative; width: 100%; max-width: 500px; aspect-ratio: 1; margin: 20px auto; background: #000; border: 3px solid #0f0; border-radius: 5px; overflow: hidden;">
                <canvas id="mazeCanvas" width="500" height="500" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%;"></canvas>
                <div id="mazeFlashlight" style="position: absolute; width: 30%; height: 30%; border-radius: 50%; pointer-events: none; background: radial-gradient(circle, rgba(255, 255, 200, 0.8) 0%, rgba(255, 255, 200, 0.4) 40%, transparent 70%); box-shadow: 0 0 60px rgba(255, 255, 200, 0.6); z-index: 10;"></div>
            </div>

            <!-- NOUVEAUX CONTRÔLES TACTILES -->
            <div style="display: flex; flex-direction: column; align-items: center; margin: 20px 0; gap: 5px;">
                <!-- Bouton Haut -->
                <button onclick="moveMazePlayerButton('up')" class="maze-btn" id="mazeBtnUp">
                    ▲
                </button>

                <!-- Boutons Gauche, Centre, Droite -->
                <div style="display: flex; gap: 5px;">
                    <button onclick="moveMazePlayerButton('left')" class="maze-btn" id="mazeBtnLeft">
                        ◀
                    </button>

                    <div style="width: 60px; height: 60px; display: flex; align-items: center; justify-content: center; background: rgba(0,0,0,0.5); border: 2px solid #666; border-radius: 5px; font-size: 28px;">
                        🔦
                    </div>

                    <button onclick="moveMazePlayerButton('right')" class="maze-btn" id="mazeBtnRight">
                        ▶
                    </button>
                </div>

                <!-- Bouton Bas -->
                <button onclick="moveMazePlayerButton('down')" class="maze-btn" id="mazeBtnDown">
                    ▼
                </button>
            </div>

            <div id="mazeMessage" style="text-align: center; min-height: 30px; font-weight: bold; margin: 10px 0;"></div>

            <div style="display: flex; gap: 10px; flex-wrap: wrap;">
                <button onclick="startMaze()" style="flex: 1; min-width: 150px;">NOUVELLE PARTIE</button>
                <button onclick="showMazeHint()" id="mazeHintBtn" style="flex: 1; min-width: 150px; background: #ffaa00;" disabled>
                    💡 INDICE (après 30s)
                </button>
            </div>
        </div>

        <!-- Détecteur d'Objets -->
        <div class="game-card">
            <h2>📷 DÉTECTEUR D'OBJETS MAUDIT</h2>
            <div class="stats">
                <div class="stat-box">
                    <div class="stat-label">Trouvés</div>
                    <div class="stat-value" id="detectFound">0/5</div>
                </div>
                <div class="stat-box">
                    <div class="stat-label">Confiance</div>
                    <div class="stat-value" id="detectConfidence">0%</div>
                </div>
                <div class="stat-box">
                    <div class="stat-label">Temps</div>
                    <div class="stat-value" id="detectTime">90s</div>
                </div>
            </div>

            <div style="text-align: center; color: #ff6600; margin: 15px 0; font-size: 16px; font-weight: bold; background: rgba(255, 102, 0, 0.1); padding: 10px; border-radius: 5px;" id="detectTarget">
                🎃 Cliquez sur DÉMARRER pour commencer
            </div>

            <!-- Caméra -->
            <div style="position: relative; max-width: 500px; margin: 20px auto;">
                <video id="detectVideo" autoplay playsinline style="width: 100%; border: 3px solid #0f0; border-radius: 10px; background: #000; display: none;"></video>
                <canvas id="detectCanvas" style="width: 100%; border: 3px solid #0f0; border-radius: 10px; background: #000;"></canvas>
                <div id="detectOverlay" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none;"></div>
            </div>

            <div id="detectMessage" style="text-align: center; min-height: 40px; font-weight: bold; margin: 15px 0; font-size: 14px;"></div>

            <div id="detectResults" style="background: rgba(0, 0, 0, 0.8); border: 2px solid #0f0; border-radius: 5px; padding: 15px; margin: 15px 0; max-height: 150px; overflow-y: auto;">
                <div style="color: #0f0; font-size: 14px; margin-bottom: 10px; text-align: center;">🔍 DÉTECTIONS :</div>
                <div id="detectList" style="color: #ffaa00; font-size: 12px; font-family: monospace;"></div>
            </div>

            <button onclick="startDetection()" id="detectStartBtn">📷 DÉMARRER LA DÉTECTION</button>
        </div>
    </div>

    <script>
        // ==================== TIR AUX CITROUILLES ====================
        let shootingActive = false;
        let shootScore = 0;
        let shootTimeLeft = 30;
        let shootInterval;
        let targetInterval;
        let shootCombo = 0;
        let shootMaxCombo = 0;

        function startShooting() {
            if (shootingActive) return;

            shootingActive = true;
            shootScore = 0;
            shootTimeLeft = 30;
            shootCombo = 0;
            shootMaxCombo = 0;
            document.getElementById('shootScore').textContent = shootScore;
            document.getElementById('shootTime').textContent = shootTimeLeft;

            const game = document.getElementById('shootingGame');
            game.innerHTML = '';
            game.style.cursor = 'crosshair';

            shootInterval = setInterval(() => {
                shootTimeLeft--;
                document.getElementById('shootTime').textContent = shootTimeLeft;

                if (shootTimeLeft <= 0) {
                    endShooting();
                }
            }, 1000);

            // Démarrer avec spawn toutes les 600ms
            targetInterval = setInterval(() => {
                spawnTarget();
                // Accélérer progressivement
                if (shootTimeLeft < 20 && shootTimeLeft % 5 === 0) {
                    clearInterval(targetInterval);
                    const newSpeed = Math.max(300, 600 - (30 - shootTimeLeft) * 20);
                    targetInterval = setInterval(spawnTarget, newSpeed);
                }
            }, 600);
        }

        function spawnTarget() {
            if (!shootingActive) return;

            const game = document.getElementById('shootingGame');

            // Types de cibles avec probabilités
            const random = Math.random();
            let targetType;

            if (random < 0.6) {
                // 60% - Citrouille normale (+1 point)
                targetType = { emoji: '🎃', points: 1, class: 'good', duration: 1500 };
            } else if (random < 0.8) {
                // 20% - Citrouille dorée (+3 points, plus rapide)
                targetType = { emoji: '🌟', points: 3, class: 'gold', duration: 1000 };
            } else if (random < 0.9) {
                // 10% - Fantôme (-2 points)
                targetType = { emoji: '👻', points: -2, class: 'bad', duration: 2000 };
            } else {
                // 10% - Crâne (-5 points)
                targetType = { emoji: '💀', points: -5, class: 'bad', duration: 2500 };
            }

            const target = document.createElement('div');
            target.className = 'shooting-target ' + targetType.class;
            target.textContent = targetType.emoji;
            target.style.position = 'absolute';
            target.style.left = Math.random() * (game.offsetWidth - 50) + 'px';
            target.style.top = Math.random() * (game.offsetHeight - 50) + 'px';
            target.style.fontSize = '40px';
            target.style.cursor = 'crosshair';
            target.style.transition = 'all 0.1s';
            target.style.userSelect = 'none';

            // Animation d'apparition
            target.style.transform = 'scale(0)';
            target.style.opacity = '0';

            target.onclick = (e) => {
                e.stopPropagation();
                if (!shootingActive) return;

                const points = targetType.points;
                shootScore += points;
                document.getElementById('shootScore').textContent = shootScore;

                // Gestion du combo
                if (points > 0) {
                    shootCombo++;
                    if (shootCombo > shootMaxCombo) {
                        shootMaxCombo = shootCombo;
                    }
                } else {
                    shootCombo = 0;
                }

                // Effet visuel selon le type
                const feedback = document.createElement('div');
                feedback.style.position = 'absolute';
                feedback.style.left = target.style.left;
                feedback.style.top = target.style.top;
                feedback.style.fontSize = '24px';
                feedback.style.fontWeight = 'bold';
                feedback.style.pointerEvents = 'none';
                feedback.style.zIndex = '1000';
                feedback.style.animation = 'fadeUp 1s forwards';

                if (points > 0) {
                    feedback.textContent = '+' + points;
                    feedback.style.color = points === 1 ? '#ff6600' : '#ffaa00';

                    const explosion = document.createElement('div');
                    explosion.textContent = '💥';
                    explosion.style.position = 'absolute';
                    explosion.style.left = target.style.left;
                    explosion.style.top = target.style.top;
                    explosion.style.fontSize = '50px';
                    explosion.style.pointerEvents = 'none';
                    game.appendChild(explosion);
                    setTimeout(() => explosion.remove(), 300);
                } else {
                    feedback.textContent = points;
                    feedback.style.color = '#f00';

                    // Flash rouge pour les mauvaises cibles
                    game.style.background = 'rgba(255, 0, 0, 0.3)';
                    setTimeout(() => {
                        game.style.background = '';
                    }, 100);
                }

                game.appendChild(feedback);
                setTimeout(() => feedback.remove(), 1000);

                target.remove();
            };

            game.appendChild(target);

            // Animation d'apparition
            setTimeout(() => {
                target.style.transform = 'scale(1)';
                target.style.opacity = '1';
            }, 10);

            // Retrait automatique
            setTimeout(() => {
                if (target.parentElement) {
                    target.style.transform = 'scale(0)';
                    target.style.opacity = '0';
                    setTimeout(() => target.remove(), 200);
                }
            }, targetType.duration);
        }

        function endShooting() {
            shootingActive = false;
            clearInterval(shootInterval);
            clearInterval(targetInterval);

            const game = document.getElementById('shootingGame');
            game.style.cursor = 'default';

            // Nettoyer toutes les cibles restantes
            const targets = game.querySelectorAll('.shooting-target');
            targets.forEach(t => t.remove());

            game.innerHTML = `<div style="display: flex; align-items: center; justify-content: center; height: 100%; flex-direction: column; color: #ff6600;">
                    <div style="font-size: 48px; margin-bottom: 20px;">🎯</div>
                    <div style="font-size: 24px;">TERMINÉ !</div>
                    <div style="font-size: 32px; margin-top: 10px; color: ${shootScore >= 0 ? '#0f0' : '#f00'};">Score: ${shootScore}</div>
                    <div style="font-size: 18px; margin-top: 10px; color: #ffaa00;">Combo Max: ${shootMaxCombo}x</div>
                </div>`;
        }


        // ==================== TYPING GAME ====================
        const typingPhrases = [
            "FUYEZ DES CITROUILLES",
            "PROJET CITROUILLE ACTIF",
            "HALLOWEEN EST ARRIVE",
            "LES CITROUILLES ATTENDENT",
            "PROTOCOLE D EVACUATION",
            "LABORATOIRE COMPROMIS",
            "SYSTEME DE SECURITE",
            "TERMINAL DE CONTROLE",
            "CONFINEMENT ROMPU",
            "NIVEAU DE DANGER MAXIMUM"
        ];

        let typingActive = false;
        let typingTimeLeft = 60;
        let typingScore = 0;
        let typingCorrect = 0;
        let typingTotal = 0;
        let typingInterval;
        let typingStartTime;

        function startTyping() {
            if (typingActive) return;

            typingActive = true;
            typingTimeLeft = 60;
            typingScore = 0;
            typingCorrect = 0;
            typingTotal = 0;
            typingStartTime = Date.now();

            document.getElementById('typingInput').disabled = false;
            document.getElementById('typingInput').value = '';
            document.getElementById('typingInput').focus();
            document.getElementById('typingMessage').innerHTML = '';

            updateTypingStats();
            nextTypingPhrase();

            typingInterval = setInterval(() => {
                typingTimeLeft--;
                document.getElementById('typingTimer').textContent = typingTimeLeft;

                if (typingTimeLeft <= 0) {
                    endTyping();
                }
            }, 1000);
        }

        function nextTypingPhrase() {
            if (!typingActive) return;

            const phrase = typingPhrases[Math.floor(Math.random() * typingPhrases.length)];
            document.getElementById('typingTarget').textContent = phrase;
            document.getElementById('typingInput').value = '';
        }

        document.getElementById('typingInput').addEventListener('input', (e) => {
            if (!typingActive) return;

            const target = document.getElementById('typingTarget').textContent;
            const input = e.target.value.toUpperCase();

            if (input === target) {
                typingScore++;
                typingCorrect++;
                typingTotal++;

                const msg = document.getElementById('typingMessage');
                msg.innerHTML = '<div class="message success">✓ CORRECT !</div>';
                setTimeout(() => msg.innerHTML = '', 500);

                nextTypingPhrase();
                updateTypingStats();
            } else if (input.length > target.length) {
                e.target.value = input.slice(0, target.length);
                typingTotal++;
                updateTypingStats();
            }
        });

        function updateTypingStats() {
            document.getElementById('typingScore').textContent = typingScore;

            const accuracy = typingTotal > 0 ? Math.round((typingCorrect / typingTotal) * 100) : 100;
            document.getElementById('typingAccuracy').textContent = accuracy + '%';

            const timeElapsed = (Date.now() - typingStartTime) / 1000 / 60;
            const wpm = timeElapsed > 0 ? Math.round(typingScore / timeElapsed) : 0;
            document.getElementById('typingWPM').textContent = wpm;
        }

        function endTyping() {
            typingActive = false;
            clearInterval(typingInterval);
            document.getElementById('typingInput').disabled = true;

            const msg = document.getElementById('typingMessage');
            msg.innerHTML = `<div class="message success">
                    🎉 TERMINÉ !<br>
                    Score: ${typingScore} phrases<br>
                    Précision: ${document.getElementById('typingAccuracy').textContent}<br>
                    Vitesse: ${document.getElementById('typingWPM').textContent} WPM
                </div>`;

            document.getElementById('typingTarget').textContent = 'Partie terminée !';
        }

        // ==================== ENDLESS RUNNER ====================
        let runnerActive = false;
        let runnerDistance = 0;
        let runnerBestDistance = 0;
        let runnerSpeed = 5;
        let runnerSpeedMultiplier = 1;
        let runnerPlayerBottom = 80;
        let runnerIsJumping = false;
        let runnerObstacles = [];
        let runnerGameLoop;
        let runnerObstacleInterval;

        const runnerObstacleTypes = ['🪦', '⚰️', '💀', '🕷️', '🦇', '👻'];
        const runnerJumpHeight = 200; // Augmenté de 150 à 200
        const runnerGravity = 2; // Réduit pour un saut plus doux

        function startRunner() {
            if (runnerActive) return;

            runnerActive = true;
            runnerDistance = 0;
            runnerSpeed = 5;
            runnerSpeedMultiplier = 1;
            runnerPlayerBottom = 80;
            runnerIsJumping = false;
            runnerObstacles = [];

            document.getElementById('runnerStartText').style.display = 'none';
            document.getElementById('runnerDistance').textContent = '0m';
            document.getElementById('runnerSpeed').textContent = '1.0x';
            document.getElementById('runnerStartBtn').disabled = true;

            // Nettoyer les anciens obstacles
            const game = document.getElementById('runnerGame');
            const oldObstacles = game.querySelectorAll('.runner-obstacle');
            oldObstacles.forEach(obs => obs.remove());

            // Démarrer les boucles
            runnerGameLoop = setInterval(updateRunner, 20);
            runnerObstacleInterval = setInterval(spawnObstacle, 1500);
        }

        function updateRunner() {
            if (!runnerActive) return;

            // Augmenter la distance
            runnerDistance += runnerSpeed / 60;
            document.getElementById('runnerDistance').textContent = Math.floor(runnerDistance) + 'm';

            // Augmenter la vitesse progressivement
            if (Math.floor(runnerDistance) % 50 === 0 && runnerDistance > 0) {
                runnerSpeed += 0.5;
                runnerSpeedMultiplier = (runnerSpeed / 5).toFixed(1);
                document.getElementById('runnerSpeed').textContent = runnerSpeedMultiplier + 'x';
            }

            // Déplacer les obstacles
            const game = document.getElementById('runnerGame');
            const obstacles = game.querySelectorAll('.runner-obstacle');

            obstacles.forEach((obstacle, index) => {
                let left = parseInt(obstacle.style.left);
                left -= runnerSpeed;
                obstacle.style.left = left + 'px';

                // Supprimer si hors écran
                if (left < -50) {
                    obstacle.remove();
                    runnerObstacles.splice(index, 1);
                }

                // Vérifier collision - CORRIGÉ
                const playerLeft = 50;
                const playerRight = playerLeft + 40; // Largeur de la citrouille
                const playerBottom = runnerPlayerBottom; // Position bottom du joueur
                const playerTop = runnerPlayerBottom + 40; // Hauteur de la citrouille

                const obsLeft = left;
                const obsRight = left + 40; // Largeur de l'obstacle
                const obsBottom = parseInt(obstacle.style.bottom); // Position bottom de l'obstacle
                const obsTop = obsBottom + 40; // Hauteur de l'obstacle

                // Collision horizontale ET verticale
                const horizontalCollision = playerRight > obsLeft + 10 && playerLeft < obsRight - 10; // Marges de 10px
                const verticalCollision = playerTop > obsBottom + 5 && playerBottom < obsTop - 5; // Marges de 5px

                if (horizontalCollision && verticalCollision) {
                    gameOverRunner();
                }
            });
        }

        function spawnObstacle() {
            if (!runnerActive) return;

            const game = document.getElementById('runnerGame');
            const obstacle = document.createElement('div');
            obstacle.className = 'runner-obstacle';

            const type = runnerObstacleTypes[Math.floor(Math.random() * runnerObstacleTypes.length)];
            obstacle.textContent = type;
            obstacle.style.position = 'absolute';
            obstacle.style.fontSize = '40px';
            obstacle.style.left = game.offsetWidth + 'px';

            // Obstacles au sol ou en l'air
            if (Math.random() > 0.8 && ['🦇', '👻'].includes(type)) {
                // Obstacles volants - hauteur entre 120 et 180px
                obstacle.style.bottom = (120 + Math.random() * 60) + 'px';
            } else {
                // Obstacles au sol
                obstacle.style.bottom = '80px';
            }

            game.appendChild(obstacle);
            runnerObstacles.push(obstacle);
        }

        function runnerJump() {
            if (!runnerActive || runnerIsJumping) return;

            runnerIsJumping = true;
            const player = document.getElementById('runnerPlayer');
            let jumpVelocity = 30; // Augmenté de 20 à 30 pour sauter plus haut

            const jumpInterval = setInterval(() => {
                runnerPlayerBottom += jumpVelocity;
                jumpVelocity -= 2; // Gravité réduite de 5 à 2 pour un saut plus doux

                player.style.bottom = runnerPlayerBottom + 'px';

                // Atterrissage
                if (runnerPlayerBottom <= 80) {
                    runnerPlayerBottom = 80;
                    player.style.bottom = '80px';
                    runnerIsJumping = false;
                    clearInterval(jumpInterval);
                }
            }, 20);
        }

        function gameOverRunner() {
            runnerActive = false;
            clearInterval(runnerGameLoop);
            clearInterval(runnerObstacleInterval);

            // Mise à jour du record
            if (Math.floor(runnerDistance) > runnerBestDistance) {
                runnerBestDistance = Math.floor(runnerDistance);
                document.getElementById('runnerBest').textContent = runnerBestDistance + 'm';
            }

            // Message de fin
            const game = document.getElementById('runnerGame');
            const gameOverMsg = document.createElement('div');
            gameOverMsg.style.position = 'absolute';
            gameOverMsg.style.top = '50%';
            gameOverMsg.style.left = '50%';
            gameOverMsg.style.transform = 'translate(-50%, -50%)';
            gameOverMsg.style.color = '#f00';
            gameOverMsg.style.fontSize = '32px';
            gameOverMsg.style.fontWeight = 'bold';
            gameOverMsg.style.textAlign = 'center';
            gameOverMsg.style.zIndex = '1000';
            gameOverMsg.style.background = 'rgba(0, 0, 0, 0.9)';
            gameOverMsg.style.padding = '30px';
            gameOverMsg.style.borderRadius = '10px';
            gameOverMsg.style.border = '3px solid #f00';
            gameOverMsg.innerHTML = `
                    💀 GAME OVER 💀<br>
                    <span style="font-size: 20px; color: #ff6600;">Distance: ${Math.floor(runnerDistance)}m</span><br>
                    <span style="font-size: 16px; color: #0f0;">Record: ${runnerBestDistance}m</span>
                `;
            game.appendChild(gameOverMsg);

            document.getElementById('runnerStartBtn').disabled = false;

            // Retirer le message après 3 secondes
            setTimeout(() => {
                gameOverMsg.remove();
                document.getElementById('runnerStartText').style.display = 'block';
            }, 3000);
        }

        // Contrôles du runner
        document.getElementById('runnerGame').addEventListener('click', runnerJump);

        document.addEventListener('keydown', (e) => {
            if (e.code === 'Space' && runnerActive) {
                e.preventDefault();
                runnerJump();
            }
        });



        // ==================== LABYRINTHE DANS LE NOIR ====================
        let mazeActive = false;
        let mazeHP = 3;
        let mazePlayer = { x: 1, y: 1 };
        let mazeExit = { x: 0, y: 0 };
        let mazeGrid = [];
        let mazeSize = 15;
        let mazeCellSize = 33;
        let mazeCanvas, mazeCtx;
        let mazeTraps = [];
        let mazeStartTime = 0;
        let mazeTimerInterval;
        let mazeKeys = {};
        let mazeOptimalPath = null;
        let mazeShowingHint = false;

        function startMaze() {
            mazeActive = true;
            mazeHP = 3;
            mazeStartTime = Date.now();

            // Initialiser canvas
            mazeCanvas = document.getElementById('mazeCanvas');
            mazeCtx = mazeCanvas.getContext('2d');

            // Activer les boutons de déplacement
            const mazeButtons = ['mazeBtnUp', 'mazeBtnDown', 'mazeBtnLeft', 'mazeBtnRight'];
            mazeButtons.forEach(btnId => {
                const btn = document.getElementById(btnId);
                if (btn) btn.disabled = false;
            });

            // Générer labyrinthe
            generateMaze();

            // Position de départ
            mazePlayer = { x: 1, y: 1 };

            // Position de sortie (coin opposé)
            mazeExit = { x: mazeSize - 2, y: mazeSize - 2 };

            // Générer des pièges
            generateTraps();

            // Stocker le chemin optimal pour les indices
            mazeOptimalPath = findPath(mazePlayer.x, mazePlayer.y, mazeExit.x, mazeExit.y);
            mazeShowingHint = false;

            // Bouton d'indice désactivé au début
            document.getElementById('mazeHintBtn').disabled = true;
            document.getElementById('mazeHintBtn').textContent = '💡 INDICE (après 30s)';

            // Activer le bouton d'indice après 30 secondes
            setTimeout(() => {
                if (mazeActive) {
                    document.getElementById('mazeHintBtn').disabled = false;
                    document.getElementById('mazeHintBtn').textContent = '💡 VOIR LE CHEMIN (1 fois)';
                }
            }, 30000);

            // Affichage
            document.getElementById('mazeHP').textContent = '❤️'.repeat(mazeHP);
            document.getElementById('mazeProgress').textContent = '0%';
            document.getElementById('mazeTime').textContent = '0s';
            document.getElementById('mazeHint').textContent = '🔦 Trouvez la sortie ! Évitez les pièges invisibles...';
            document.getElementById('mazeHint').style.color = '#0f0';
            document.getElementById('mazeMessage').innerHTML = '';

            // Timer
            clearInterval(mazeTimerInterval);
            mazeTimerInterval = setInterval(() => {
                if (mazeActive) {
                    const elapsed = Math.floor((Date.now() - mazeStartTime) / 1000);
                    document.getElementById('mazeTime').textContent = elapsed + 's';
                }
            }, 1000);

            // Dessiner
            drawMaze();
        }

        function generateMaze() {
            // Créer grille vide (1 = mur, 0 = chemin)
            mazeGrid = [];
            for (let y = 0; y < mazeSize; y++) {
                mazeGrid[y] = [];
                for (let x = 0; x < mazeSize; x++) {
                    mazeGrid[y][x] = 1;
                }
            }

            // Algorithme de génération simple (DFS)
            const stack = [];
            const startX = 1, startY = 1;
            mazeGrid[startY][startX] = 0;
            stack.push({ x: startX, y: startY });

            const directions = [
                { dx: 2, dy: 0 },
                { dx: -2, dy: 0 },
                { dx: 0, dy: 2 },
                { dx: 0, dy: -2 }
            ];

            while (stack.length > 0) {
                const current = stack[stack.length - 1];
                const neighbors = [];

                // Chercher voisins non visités
                directions.forEach(dir => {
                    const nx = current.x + dir.dx;
                    const ny = current.y + dir.dy;

                    if (nx > 0 && nx < mazeSize - 1 && ny > 0 && ny < mazeSize - 1 && mazeGrid[ny][nx] === 1) {
                        neighbors.push({ x: nx, y: ny, dx: dir.dx, dy: dir.dy });
                    }
                });

                if (neighbors.length > 0) {
                    // Choisir voisin aléatoire
                    const next = neighbors[Math.floor(Math.random() * neighbors.length)];

                    // Creuser chemin
                    mazeGrid[next.y][next.x] = 0;
                    mazeGrid[current.y + next.dy / 2][current.x + next.dx / 2] = 0;

                    stack.push({ x: next.x, y: next.y });
                } else {
                    stack.pop();
                }
            }
        }

        function generateTraps() {
            mazeTraps = [];

            // Trouver le chemin optimal avec BFS
            const optimalPath = findPath(mazePlayer.x, mazePlayer.y, mazeExit.x, mazeExit.y);

            if (!optimalPath) {
                console.error("Pas de chemin trouvé !");
                return;
            }

            // Créer un Set des positions du chemin optimal pour accès rapide
            const pathSet = new Set(optimalPath.map(p => `${p.x},${p.y}`));

            // Calculer combien de pièges on peut mettre sur le chemin (max 2 pour rester jouable avec 3 vies)
            const maxTrapsOnPath = 2;
            let trapsOnPath = 0;

            // Placer 10-15 pièges au total
            let trapCount = 10 + Math.floor(Math.random() * 6);

            for (let i = 0; i < trapCount; i++) {
                let x, y;
                let isOnPath = false;
                let attempts = 0;

                do {
                    x = Math.floor(Math.random() * mazeSize);
                    y = Math.floor(Math.random() * mazeSize);
                    isOnPath = pathSet.has(`${x},${y}`);
                    attempts++;

                    // Si on a essayé trop de fois, forcer un placement hors chemin
                    if (attempts > 100) break;

                } while (
                    mazeGrid[y][x] === 1 || // Mur
                    (x === 1 && y === 1) || // Départ
                    (x === mazeExit.x && y === mazeExit.y) || // Sortie
                    mazeTraps.some(t => t.x === x && t.y === y) || // Déjà un piège
                    (isOnPath && trapsOnPath >= maxTrapsOnPath) // Trop de pièges sur le chemin
                );

                if (attempts > 100) continue; // Skip si impossible

                if (isOnPath) {
                    trapsOnPath++;
                }

                mazeTraps.push({
                    x, y,
                    triggered: false,
                    type: Math.random() > 0.5 ? 'spike' : 'hole'
                });
            }
        }

        // BFS pour trouver le chemin optimal
        function findPath(startX, startY, endX, endY) {
            const queue = [{ x: startX, y: startY, path: [{ x: startX, y: startY }] }];
            const visited = new Set([`${startX},${startY}`]);

            const directions = [
                { dx: 0, dy: -1 }, // Haut
                { dx: 0, dy: 1 },  // Bas
                { dx: -1, dy: 0 }, // Gauche
                { dx: 1, dy: 0 }   // Droite
            ];

            while (queue.length > 0) {
                const current = queue.shift();

                // Arrivée !
                if (current.x === endX && current.y === endY) {
                    return current.path;
                }

                // Explorer voisins
                for (const dir of directions) {
                    const newX = current.x + dir.dx;
                    const newY = current.y + dir.dy;
                    const key = `${newX},${newY}`;

                    // Vérifier validité
                    if (newX >= 0 && newX < mazeSize &&
                        newY >= 0 && newY < mazeSize &&
                        mazeGrid[newY][newX] === 0 &&
                        !visited.has(key)) {

                        visited.add(key);
                        queue.push({
                            x: newX,
                            y: newY,
                            path: [...current.path, { x: newX, y: newY }]
                        });
                    }
                }
            }

            return null; // Pas de chemin trouvé
        }

        function drawMaze() {
            if (!mazeActive) return;

            // Fond noir
            mazeCtx.fillStyle = '#000';
            mazeCtx.fillRect(0, 0, mazeCanvas.width, mazeCanvas.height);

            // Ne dessiner que ce qui est visible dans le rayon de la lampe
            const visionRadius = 2.5; // Cellules visibles autour du joueur

            for (let y = 0; y < mazeSize; y++) {
                for (let x = 0; x < mazeSize; x++) {
                    const distance = Math.sqrt(
                        Math.pow(x - mazePlayer.x, 2) +
                        Math.pow(y - mazePlayer.y, 2)
                    );

                    if (distance <= visionRadius) {
                        const opacity = Math.max(0, 1 - distance / visionRadius);

                        // Dessiner cellule
                        if (mazeGrid[y][x] === 1) {
                            // Mur
                            mazeCtx.fillStyle = `rgba(139, 69, 19, ${opacity})`;
                        } else {
                            // Chemin
                            mazeCtx.fillStyle = `rgba(40, 40, 40, ${opacity})`;
                        }

                        mazeCtx.fillRect(
                            x * mazeCellSize,
                            y * mazeCellSize,
                            mazeCellSize - 1,
                            mazeCellSize - 1
                        );

                        // Dessiner pièges déclenchés
                        const trap = mazeTraps.find(t => t.x === x && t.y === y && t.triggered);
                        if (trap) {
                            mazeCtx.fillStyle = `rgba(139, 0, 0, ${opacity})`;
                            mazeCtx.font = '20px Arial';
                            mazeCtx.fillText(
                                trap.type === 'spike' ? '🗡️' : '🕳️',
                                x * mazeCellSize + 6,
                                y * mazeCellSize + 24
                            );
                        }
                    }
                }
            }

            // Dessiner le chemin optimal si l'indice est activé
            if (mazeShowingHint && mazeOptimalPath) {
                mazeOptimalPath.forEach(pathCell => {
                    const distance = Math.sqrt(
                        Math.pow(pathCell.x - mazePlayer.x, 2) +
                        Math.pow(pathCell.y - mazePlayer.y, 2)
                    );

                    // Dessiner même hors du rayon de vision pour l'indice
                    const opacity = distance <= visionRadius ?
                        Math.max(0, 1 - distance / visionRadius) : 0.3;

                    mazeCtx.fillStyle = `rgba(255, 215, 0, ${opacity * 0.6})`;
                    mazeCtx.fillRect(
                        pathCell.x * mazeCellSize + 10,
                        pathCell.y * mazeCellSize + 10,
                        mazeCellSize - 20,
                        mazeCellSize - 20
                    );
                });
            }

            // Dessiner sortie si visible
            const exitDistance = Math.sqrt(
                Math.pow(mazeExit.x - mazePlayer.x, 2) +
                Math.pow(mazeExit.y - mazePlayer.y, 2)
            );

            if (exitDistance <= visionRadius) {
                const opacity = Math.max(0, 1 - exitDistance / visionRadius);
                mazeCtx.fillStyle = `rgba(0, 255, 0, ${opacity * 0.5})`;
                mazeCtx.fillRect(
                    mazeExit.x * mazeCellSize,
                    mazeExit.y * mazeCellSize,
                    mazeCellSize - 1,
                    mazeCellSize - 1
                );

                mazeCtx.font = '24px Arial';
                mazeCtx.fillStyle = `rgba(0, 255, 0, ${opacity})`;
                mazeCtx.fillText('🚪', mazeExit.x * mazeCellSize + 4, mazeExit.y * mazeCellSize + 25);
            }

            // Dessiner joueur
            mazeCtx.font = '28px Arial';
            mazeCtx.fillStyle = '#FFD700';
            mazeCtx.fillText('🔦', mazePlayer.x * mazeCellSize + 2, mazePlayer.y * mazeCellSize + 26);

            // Positionner la lampe torche (responsive et centrée)
            const flashlight = document.getElementById('mazeFlashlight');
            const containerRect = mazeCanvas.getBoundingClientRect();
            const flashlightSize = containerRect.width * 0.3; // 30% de la largeur

            // Calculer la position relative du joueur sur le canvas affiché
            const playerScreenX = (mazePlayer.x * mazeCellSize / 500) * containerRect.width;
            const playerScreenY = (mazePlayer.y * mazeCellSize / 500) * containerRect.height;

            // Centrer la lampe sur le joueur
            flashlight.style.left = (playerScreenX - flashlightSize / 2) + 'px';
            flashlight.style.top = (playerScreenY - flashlightSize / 2) + 'px';

            // Calculer progression
            const totalDistance = Math.sqrt(
                Math.pow(mazeExit.x - 1, 2) +
                Math.pow(mazeExit.y - 1, 2)
            );
            const currentDistance = Math.sqrt(
                Math.pow(mazeExit.x - mazePlayer.x, 2) +
                Math.pow(mazeExit.y - mazePlayer.y, 2)
            );
            const progress = Math.max(0, Math.min(100, Math.floor((1 - currentDistance / totalDistance) * 100)));
            document.getElementById('mazeProgress').textContent = progress + '%';

            requestAnimationFrame(drawMaze);
        }

        // Fonction pour les boutons tactiles
        function moveMazePlayerButton(direction) {
            if (!mazeActive) return;

            let dx = 0, dy = 0;

            switch (direction) {
                case 'up':
                    dy = -1;
                    break;
                case 'down':
                    dy = 1;
                    break;
                case 'left':
                    dx = -1;
                    break;
                case 'right':
                    dx = 1;
                    break;
            }

            // Appeler la fonction de mouvement existante
            moveMazePlayer(dx, dy);

            // Animation du bouton
            const buttonIds = {
                'up': 'mazeBtnUp',
                'down': 'mazeBtnDown',
                'left': 'mazeBtnLeft',
                'right': 'mazeBtnRight'
            };

            const btn = document.getElementById(buttonIds[direction]);
            if (btn) {
                btn.classList.add('pressed');
                setTimeout(() => btn.classList.remove('pressed'), 200);
            }
        }

        function moveMazePlayer(dx, dy) {
            if (!mazeActive) return;

            const newX = mazePlayer.x + dx;
            const newY = mazePlayer.y + dy;

            // Vérifier limites et murs
            if (newX < 0 || newX >= mazeSize || newY < 0 || newY >= mazeSize) return;
            if (mazeGrid[newY][newX] === 1) {
                // Collision avec mur
                document.getElementById('mazeHint').textContent = '🧱 Vous heurtez un mur !';
                document.getElementById('mazeHint').style.color = '#ff6600';
                return;
            }

            // Déplacer
            mazePlayer.x = newX;
            mazePlayer.y = newY;

            // Vérifier piège
            const trap = mazeTraps.find(t => t.x === newX && t.y === newY && !t.triggered);
            if (trap) {
                trap.triggered = true;
                mazeHP--;
                document.getElementById('mazeHP').textContent = '❤️'.repeat(Math.max(0, mazeHP)) + '🖤'.repeat(3 - mazeHP);

                const trapEmoji = trap.type === 'spike' ? '🗡️' : '🕳️';
                const trapName = trap.type === 'spike' ? 'Piques' : 'Fosse';

                document.getElementById('mazeHint').textContent = `${trapEmoji} ${trapName} ! -1 vie`;
                document.getElementById('mazeHint').style.color = '#f00';

                // Flash rouge
                mazeCanvas.style.background = 'rgba(255, 0, 0, 0.3)';
                setTimeout(() => {
                    mazeCanvas.style.background = '#000';
                }, 200);

                if (mazeHP <= 0) {
                    loseMaze();
                    return;
                }
            }

            // Vérifier sortie
            if (mazePlayer.x === mazeExit.x && mazePlayer.y === mazeExit.y) {
                winMaze();
            }
        }

        function winMaze() {
            mazeActive = false;
            clearInterval(mazeTimerInterval);

            const time = Math.floor((Date.now() - mazeStartTime) / 1000);
            const trapsHit = 3 - mazeHP;

            // Désactiver les boutons
            const mazeButtons = ['mazeBtnUp', 'mazeBtnDown', 'mazeBtnLeft', 'mazeBtnRight'];
            mazeButtons.forEach(btnId => {
                const btn = document.getElementById(btnId);
                if (btn) btn.disabled = true;
            });

            document.getElementById('mazeMessage').innerHTML = `
                    <div style="color: #0f0; font-size: 18px;">
                        🎉 SORTIE TROUVÉE !<br>
                        <span style="font-size: 14px;">Temps: ${time}s | Pièges: ${trapsHit}/3 | Vies: ${mazeHP}❤️</span>
                    </div>
                `;

            document.getElementById('mazeHint').textContent = '🚪 Vous avez échappé au labyrinthe !';
            document.getElementById('mazeHint').style.color = '#0f0';
        }

        function loseMaze() {
            mazeActive = false;
            clearInterval(mazeTimerInterval);

            // Désactiver les boutons
            const mazeButtons = ['mazeBtnUp', 'mazeBtnDown', 'mazeBtnLeft', 'mazeBtnRight'];
            mazeButtons.forEach(btnId => {
                const btn = document.getElementById(btnId);
                if (btn) btn.disabled = true;
            });

            document.getElementById('mazeMessage').innerHTML = `
                    <div style="color: #f00; font-size: 18px;">
                        💀 VOUS ÊTES PERDU...<br>
                        <span style="font-size: 14px;">Vous avez succombé aux pièges du labyrinthe</span>
                    </div>
                `;

            document.getElementById('mazeHint').textContent = '☠️ Trop de blessures... Réessayez !';
            document.getElementById('mazeHint').style.color = '#f00';
        }

        function showMazeHint() {
            if (!mazeActive || mazeShowingHint || !mazeOptimalPath) return;

            mazeShowingHint = true;
            document.getElementById('mazeHintBtn').disabled = true;
            document.getElementById('mazeHintBtn').textContent = '💡 INDICE UTILISÉ';

            document.getElementById('mazeHint').textContent = '💡 Le chemin s\'illumine pendant 5 secondes...';
            document.getElementById('mazeHint').style.color = '#ffaa00';

            // Réactiver après 5 secondes
            setTimeout(() => {
                mazeShowingHint = false;
                if (mazeActive) {
                    document.getElementById('mazeHint').textContent = '🔦 Continuez vers la sortie...';
                    document.getElementById('mazeHint').style.color = '#0f0';
                }
            }, 5000);
        }

        // Contrôles clavier du labyrinthe
        document.addEventListener('keydown', (e) => {
            if (!mazeActive) return;

            switch (e.key) {
                case 'ArrowUp':
                case 'z':
                case 'Z':
                    e.preventDefault();
                    moveMazePlayer(0, -1);
                    break;
                case 'ArrowDown':
                case 's':
                case 'S':
                    e.preventDefault();
                    moveMazePlayer(0, 1);
                    break;
                case 'ArrowLeft':
                case 'q':
                case 'Q':
                    e.preventDefault();
                    moveMazePlayer(-1, 0);
                    break;
                case 'ArrowRight':
                case 'd':
                case 'D':
                    e.preventDefault();
                    moveMazePlayer(1, 0);
                    break;
            }
        });

        // ==================== DÉTECTEUR D'OBJETS ====================
        let detectActive = false;
        let detectVideo, detectCanvas, detectCtx;
        let detectModel = null;
        let detectStream = null;
        let detectFound = 0;
        let detectTargetObjects = [];
        let detectFoundObjects = [];
        let detectTimeLeft = 90;
        let detectTimerInterval;
        let detectAnimationFrame;

        // Liste d'objets à trouver (COCO dataset)
        const detectObjectPool = [
            { name: 'person', emoji: '🧍', fr: 'Une personne' },
            { name: 'cell phone', emoji: '📱', fr: 'Un téléphone' },
            { name: 'book', emoji: '📖', fr: 'Un livre' },
            { name: 'bottle', emoji: '🍾', fr: 'Une bouteille' },
            { name: 'cup', emoji: '☕', fr: 'Une tasse' },
            { name: 'keyboard', emoji: '⌨️', fr: 'Un clavier' },
            { name: 'mouse', emoji: '🖱️', fr: 'Une souris' },
            { name: 'laptop', emoji: '💻', fr: 'Un ordinateur' },
            { name: 'chair', emoji: '🪑', fr: 'Une chaise' },
            { name: 'clock', emoji: '🕐', fr: 'Une horloge' },
            { name: 'scissors', emoji: '✂️', fr: 'Des ciseaux' },
            { name: 'teddy bear', emoji: '🧸', fr: 'Un ours en peluche' },
            { name: 'toothbrush', emoji: '🪥', fr: 'Une brosse à dents' },
            { name: 'spoon', emoji: '🥄', fr: 'Une cuillère' },
            { name: 'fork', emoji: '🍴', fr: 'Une fourchette' },
            { name: 'knife', emoji: '🔪', fr: 'Un couteau' },
            { name: 'bowl', emoji: '🥣', fr: 'Un bol' },
            { name: 'banana', emoji: '🍌', fr: 'Une banane' },
            { name: 'apple', emoji: '🍎', fr: 'Une pomme' },
            { name: 'orange', emoji: '🍊', fr: 'Une orange' }
        ];

        async function startDetection() {
            document.getElementById('detectStartBtn').disabled = true;
            document.getElementById('detectStartBtn').textContent = '⏳ Chargement du modèle IA...';
            document.getElementById('detectMessage').innerHTML = '<div style="color: #ffaa00;">🤖 Chargement de TensorFlow.js et COCO-SSD...</div>';

            try {
                // Charger TensorFlow.js et COCO-SSD
                if (!window.cocoSsd) {
                    // Charger les scripts si pas déjà chargés
                    await loadScript('https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.11.0');
                    await loadScript('https://cdn.jsdelivr.net/npm/@tensorflow-models/coco-ssd@2.2.3');
                }

                document.getElementById('detectMessage').innerHTML = '<div style="color: #ffaa00;">📷 Activation de la caméra...</div>';

                // Initialiser les éléments
                detectVideo = document.getElementById('detectVideo');
                detectCanvas = document.getElementById('detectCanvas');
                detectCtx = detectCanvas.getContext('2d');

                // Demander accès caméra
                detectStream = await navigator.mediaDevices.getUserMedia({
                    video: { facingMode: 'environment' }
                });
                detectVideo.srcObject = detectStream;

                await new Promise(resolve => {
                    detectVideo.onloadedmetadata = resolve;
                });

                // Ajuster taille canvas
                detectCanvas.width = detectVideo.videoWidth;
                detectCanvas.height = detectVideo.videoHeight;

                document.getElementById('detectMessage').innerHTML = '<div style="color: #ffaa00;">🧠 Chargement du modèle de détection...</div>';

                // Charger le modèle
                detectModel = await cocoSsd.load();

                // Initialiser le jeu
                detectActive = true;
                detectFound = 0;
                detectFoundObjects = [];
                detectTimeLeft = 90;

                // Sélectionner 5 objets aléatoires
                const shuffled = [...detectObjectPool].sort(() => Math.random() - 0.5);
                detectTargetObjects = shuffled.slice(0, 5);

                document.getElementById('detectFound').textContent = '0/5';
                document.getElementById('detectConfidence').textContent = '0%';
                document.getElementById('detectTime').textContent = detectTimeLeft + 's';

                updateTargetDisplay();

                document.getElementById('detectMessage').innerHTML = '<div style="color: #0f0;">✅ Prêt ! Montrez les objets à la caméra</div>';
                document.getElementById('detectStartBtn').textContent = '🛑 ARRÊTER';
                document.getElementById('detectStartBtn').onclick = stopDetection;
                document.getElementById('detectStartBtn').disabled = false;

                // Timer
                clearInterval(detectTimerInterval);
                detectTimerInterval = setInterval(() => {
                    if (detectActive) {
                        detectTimeLeft--;
                        document.getElementById('detectTime').textContent = detectTimeLeft + 's';

                        if (detectTimeLeft <= 0) {
                            loseDetection();
                        } else if (detectTimeLeft <= 15) {
                            document.getElementById('detectTime').style.color = '#f00';
                        }
                    }
                }, 1000);

                // Lancer la détection
                detectLoop();

            } catch (error) {
                console.error('Erreur:', error);
                document.getElementById('detectMessage').innerHTML = `
                        <div style="color: #f00;">
                            ❌ Erreur: ${error.message}<br>
                            <span style="font-size: 12px;">Vérifiez que vous avez autorisé l'accès à la caméra</span>
                        </div>
                    `;
                document.getElementById('detectStartBtn').disabled = false;
                document.getElementById('detectStartBtn').textContent = '📷 RÉESSAYER';
            }
        }

        function loadScript(src) {
            return new Promise((resolve, reject) => {
                const script = document.createElement('script');
                script.src = src;
                script.onload = resolve;
                script.onerror = reject;
                document.head.appendChild(script);
            });
        }

        async function detectLoop() {
            if (!detectActive) return;

            // Dessiner la vidéo sur le canvas
            detectCtx.drawImage(detectVideo, 0, 0, detectCanvas.width, detectCanvas.height);

            // Détecter les objets
            const predictions = await detectModel.detect(detectCanvas);

            // Traiter les prédictions
            let maxConfidence = 0;
            predictions.forEach(prediction => {
                const [x, y, width, height] = prediction.bbox;
                const objectName = prediction.class;
                const confidence = prediction.score;

                maxConfidence = Math.max(maxConfidence, confidence);

                // Vérifier si c'est un objet recherché
                const targetIndex = detectTargetObjects.findIndex(obj =>
                    obj.name === objectName && !detectFoundObjects.includes(obj.name)
                );

                if (targetIndex !== -1 && confidence > 0.6) {
                    // Objet trouvé !
                    const target = detectTargetObjects[targetIndex];
                    detectFoundObjects.push(target.name);
                    detectFound++;

                    document.getElementById('detectFound').textContent = detectFound + '/5';

                    // Flash vert
                    detectCanvas.style.borderColor = '#0f0';
                    setTimeout(() => {
                        detectCanvas.style.borderColor = '#0f0';
                    }, 500);

                    // Message
                    document.getElementById('detectMessage').innerHTML = `
                            <div style="color: #0f0; font-size: 16px;">
                                ✅ ${target.emoji} ${target.fr} trouvé ! (${Math.floor(confidence * 100)}%)
                            </div>
                        `;

                    updateTargetDisplay();

                    // Vérifier victoire
                    if (detectFound >= 5) {
                        setTimeout(winDetection, 1000);
                        return;
                    }
                }

                // Dessiner les boîtes de détection
                detectCtx.strokeStyle = targetIndex !== -1 && !detectFoundObjects.includes(objectName) ? '#0f0' : '#ff6600';
                detectCtx.lineWidth = 3;
                detectCtx.strokeRect(x, y, width, height);

                // Label
                detectCtx.fillStyle = detectCtx.strokeStyle;
                detectCtx.font = '16px Arial';
                detectCtx.fillText(
                    `${objectName} ${Math.floor(confidence * 100)}%`,
                    x, y > 20 ? y - 5 : y + height + 20
                );
            });

            document.getElementById('detectConfidence').textContent = Math.floor(maxConfidence * 100) + '%';

            // Liste des détections
            updateDetectionList(predictions);

            detectAnimationFrame = requestAnimationFrame(detectLoop);
        }

        function updateTargetDisplay() {
            let html = '';
            detectTargetObjects.forEach(obj => {
                const found = detectFoundObjects.includes(obj.name);
                const style = found ?
                    'text-decoration: line-through; color: #666; opacity: 0.5;' :
                    'color: #ff6600; font-weight: bold;';
                html += `<div style="${style}">${found ? '✅' : '🎯'} ${obj.emoji} ${obj.fr}</div>`;
            });
            document.getElementById('detectTarget').innerHTML = html;
        }

        function updateDetectionList(predictions) {
            if (predictions.length === 0) {
                document.getElementById('detectList').textContent = '⚠️ Aucun objet détecté';
                return;
            }

            let html = '';
            predictions.forEach(pred => {
                html += `• ${pred.class}: ${Math.floor(pred.score * 100)}%<br>`;
            });
            document.getElementById('detectList').innerHTML = html;
        }

        function stopDetection() {
            detectActive = false;
            clearInterval(detectTimerInterval);
            cancelAnimationFrame(detectAnimationFrame);

            if (detectStream) {
                detectStream.getTracks().forEach(track => track.stop());
            }

            detectCtx.clearRect(0, 0, detectCanvas.width, detectCanvas.height);

            document.getElementById('detectStartBtn').textContent = '📷 DÉMARRER LA DÉTECTION';
            document.getElementById('detectStartBtn').onclick = startDetection;
            document.getElementById('detectMessage').innerHTML = '<div style="color: #666;">⏹️ Détection arrêtée</div>';
        }

        function winDetection() {
            detectActive = false;
            clearInterval(detectTimerInterval);

            const timeBonus = detectTimeLeft * 10;

            document.getElementById('detectMessage').innerHTML = `
                    <div style="color: #0f0; font-size: 18px;">
                        🎉 MISSION ACCOMPLIE !<br>
                        <span style="font-size: 14px;">Tous les objets trouvés ! Bonus: ${timeBonus}pts</span>
                    </div>
                `;

            setTimeout(stopDetection, 3000);
        }

        function loseDetection() {
            detectActive = false;
            clearInterval(detectTimerInterval);

            document.getElementById('detectMessage').innerHTML = `
                    <div style="color: #f00; font-size: 18px;">
                        ⏰ TEMPS ÉCOULÉ !<br>
                        <span style="font-size: 14px;">Objets trouvés: ${detectFound}/5</span>
                    </div>
                `;

            setTimeout(stopDetection, 3000);
        }

    </script>
</body>
</html>